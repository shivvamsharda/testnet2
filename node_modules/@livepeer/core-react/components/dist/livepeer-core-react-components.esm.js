import * as React from 'react';
import { u as useLivepeerProvider, d as useMemoizedIcon, c as useConditionalIcon, a as useCreateAsset, b as usePlaybackInfo } from '../../dist/system-f1ea33f2.esm.js';
import { isAccessControlError, isStreamOfflineError, getMediaSourceType, isBframesError, isNotAcceptableError } from '@livepeer/core';
import { parseCid, parseArweaveTxId, isNumber } from '@livepeer/core/utils';
import { u as useInternalQuery } from '../../dist/useInternalQuery-9e9dd997.esm.js';
import '@livepeer/core/actions';
import '@livepeer/core/client';
import 'use-sync-external-store/shim/with-selector.js';
import '@tanstack/react-query';
import '../../dist/client-c79d9b6b.esm.js';
import '@tanstack/query-async-storage-persister';
import '@tanstack/react-query-persist-client';
import '../../dist/LivepeerConfig-bc769187.esm.js';
import 'react/jsx-runtime';

const useBroadcast = ({
  streamKey,
  children,
  controls,
  theme,
  title,
  onError,
  aspectRatio = '16to9',
  objectFit = 'contain',
  mediaElementRef,
  onPlaybackStatusUpdate,
  playbackStatusSelector,
  renderChildrenOutsideContainer
}) => {
  const provider = useLivepeerProvider();
  const ingestUrl = React.useMemo(() => {
    const baseUrl = provider.getConfig().webrtcIngestBaseUrl;
    if (!streamKey || !baseUrl) {
      return null;
    }
    return `${baseUrl}/${streamKey}`;
  }, [streamKey, provider]);
  const [mediaElement, setMediaElement] = React.useState(null);
  const [broadcastError, setBroadcastError] = React.useState(null);
  const onBroadcastError = React.useCallback(error => {
    const newError = error ? {
      type: isAccessControlError(error) ? 'access-control' : isStreamOfflineError(error) ? 'offline' : 'unknown',
      message: error?.message ?? 'Error with playback.'
    } : null;
    setBroadcastError(newError);
    if (error) {
      console.warn(error);
      onError?.(error);
    }
    return error;
  }, [onError]);
  React.useEffect(() => {
    if (streamKey) {
      setBroadcastError(null);
    }
  }, [streamKey]);
  const broadcastRef = React.useCallback(element => {
    if (element) {
      setMediaElement(element);
      mediaElementRef?.(element);
    }
  }, [mediaElementRef]);
  const broadcastProps = React.useMemo(() => ({
    ref: broadcastRef,
    ingestUrl,
    objectFit: objectFit,
    options: controls,
    broadcastError,
    onBroadcastError,
    onPlaybackStatusUpdate,
    playbackStatusSelector
  }), [broadcastError, broadcastRef, controls, ingestUrl, objectFit, onBroadcastError, onPlaybackStatusUpdate, playbackStatusSelector]);
  const mediaControllerProps = React.useMemo(() => ({
    autoPlay: false,
    playbackId: undefined,
    muted: false,
    priority: false,
    ingestUrl: ingestUrl ?? undefined
  }), [ingestUrl]);
  const controlsContainerProps = React.useMemo(() => ({
    hidePosterOnPlayed: true,
    showLoadingSpinner: true,
    loadingText: null,
    showUploadingIndicator: false,
    error: broadcastError
  }), [broadcastError]);
  const props = React.useMemo(() => ({
    ingestUrl,
    children,
    controls,
    theme,
    title,
    aspectRatio,
    objectFit,
    onBroadcastError,
    onPlaybackStatusUpdate,
    renderChildrenOutsideContainer
  }), [ingestUrl, aspectRatio, children, controls, objectFit, theme, title, onBroadcastError, onPlaybackStatusUpdate, renderChildrenOutsideContainer]);
  return {
    mediaElement,
    broadcastProps,
    mediaControllerProps,
    controlsContainerProps,
    props
  };
};

const useBaseSlider = props => {
  const [localX, setLocalX] = React.useState(null);
  const {
    onChange,
    thumbIcon,
    defaultThumbIcon,
    sliderWidth,
    ariaName,
    isActive,
    leftCss,
    middleCss,
    rightCss,
    thumbCss
  } = props;
  const isActiveOrDragging = isActive || localX !== null;
  const onUpdate = React.useCallback(async (locationX, isComplete) => {
    if (sliderWidth) {
      const newValue = locationX / sliderWidth;
      const newBoundedValue = Math.min(Math.max(0, newValue), 1);
      if (isComplete) {
        await onChange?.(newBoundedValue);
        setLocalX(null);
      } else {
        setLocalX(newBoundedValue);
      }
    }
  }, [onChange, sliderWidth]);
  const {
    value,
    middleValue
  } = React.useMemo(() => {
    const value = localX !== null ? localX : !isNaN(props.value) ? props.value : 0;
    const middleValue = localX !== null ? 0 : props.secondaryValue && !isNaN(props.value) && !isNaN(props.secondaryValue) ? props.secondaryValue - props.value : 0;
    return {
      value,
      middleValue: middleValue > 0 ? middleValue : 0
    };
  }, [localX, props.value, props.secondaryValue]);
  const thumbProps = React.useMemo(() => ({
    css: {
      ...thumbCss,
      zIndex: 1
    },
    size: isActiveOrDragging ? 'active' : 'default'
  }), [thumbCss, isActiveOrDragging]);
  const handle = useMemoizedIcon(thumbIcon, /*#__PURE__*/React.cloneElement(defaultThumbIcon, thumbProps));
  const rightValue = React.useMemo(() => 1 - (value + middleValue), [value, middleValue]);
  const valueRounded = React.useMemo(() => Math.round(value * 100), [value]);
  return {
    title: `${valueRounded}% ${ariaName}`,
    value: valueRounded,
    active: isActiveOrDragging,
    handle,
    sliderProps: {
      onUpdate
    },
    sliderLeftTrackProps: {
      shown: value > 0.001,
      rounded: value === 1 && !isActiveOrDragging ? 'full' : 'left',
      css: {
        ...leftCss,
        flex: value
      }
    },
    sliderMiddleTrackProps: {
      shown: (middleValue ?? 0) > 0,
      rounded: middleValue === 1 ? !isActiveOrDragging ? 'full' : 'right' : value <= 0.001 ? 'left' : rightValue === 0 ? 'right' : 'none',
      css: {
        ...middleCss,
        flex: middleValue
      }
    },
    sliderRightTrackProps: {
      shown: (rightValue ?? 0) > 0,
      rounded: value <= 0.001 && !isActiveOrDragging ? 'full' : 'right',
      css: {
        ...rightCss,
        flex: rightValue
      }
    }
  };
};

const useClipButton = props => {
  const {
    onPress,
    live,
    requestClip,
    playbackId,
    defaultIcon,
    clipStatus,
    length,
    ...rest
  } = props;
  const onPressComposed = React.useCallback(async () => {
    await onPress?.();
    await requestClip();
  }, [onPress, requestClip]);
  const title = React.useMemo(() => `Clip last ${Number(length).toFixed(0)}s (x)`, [length]);
  const isShown = React.useMemo(() => playbackId && live, [playbackId, live]);
  return {
    title,
    isShown: isShown,
    status: clipStatus,
    buttonProps: {
      onPress: onPressComposed,
      children: defaultIcon,
      ...rest
    }
  };
};

const useControlsContainer = props => {
  const {
    togglePlay,
    canPlay,
    buffered,
    isBroadcast,
    _updateLastInteraction
  } = props;
  const isLoaded = React.useMemo(() => canPlay || buffered !== 0, [canPlay, buffered]);
  const onPressBackground = React.useCallback(() => {
    if (isLoaded) {
      if (!isBroadcast) {
        togglePlay();
      } else {
        _updateLastInteraction();
      }
    }
  }, [togglePlay, isLoaded, isBroadcast, _updateLastInteraction]);
  return {
    isLoaded,
    containerProps: {
      onPress: onPressBackground
    }
  };
};

const useFullscreenButton = props => {
  const {
    enterIcon,
    exitIcon,
    onPress,
    fullscreen,
    pictureInPicture,
    requestToggleFullscreen,
    defaultEnterIcon,
    defaultExitIcon,
    ...rest
  } = props;
  const onPressComposed = React.useCallback(async () => {
    await onPress?.();
    await requestToggleFullscreen();
  }, [onPress, requestToggleFullscreen]);
  const _children = useConditionalIcon(fullscreen, exitIcon, defaultExitIcon, enterIcon, defaultEnterIcon);
  const title = React.useMemo(() => fullscreen ? 'Exit full screen (f)' : 'Full screen (f)', [fullscreen]);
  return {
    title,
    buttonProps: pictureInPicture ? null : {
      onPress: onPressComposed,
      children: _children,
      ...rest
    }
  };
};

const usePlayButton = props => {
  const {
    playIcon,
    pauseIcon,
    onPress,
    togglePlay,
    playing,
    defaultPauseIcon,
    defaultPlayIcon,
    ...rest
  } = props;
  const onPressComposed = async () => {
    await onPress?.();
    await togglePlay();
  };
  const _children = useConditionalIcon(playing, pauseIcon, defaultPauseIcon, playIcon, defaultPlayIcon);
  const title = React.useMemo(() => playing ? 'Pause (k)' : 'Play (k)', [playing]);
  return {
    title,
    buttonProps: {
      onPress: onPressComposed,
      children: _children,
      ...rest
    }
  };
};

const useProgress = props => {
  const {
    duration,
    progress,
    requestSeek,
    buffered,
    live,
    ...rest
  } = props;
  const [min, max, current] = React.useMemo(() => [0, duration && !isNaN(duration) ? duration : 0, progress && !isNaN(progress) ? progress : 0], [duration, progress]);
  const value = React.useMemo(() => current / (max - min), [min, max, current]);
  const secondaryValue = React.useMemo(() => buffered / (max - min), [min, max, buffered]);
  const onChange = React.useCallback(async value => {
    const newSeek = value * (max - min);
    await props?.onSeek?.(newSeek);
    requestSeek(newSeek);
  }, [max, min, requestSeek, props]);
  const durationMinutes = React.useMemo(() => (duration / 60).toFixed(1), [duration]);
  return {
    isVisible: !live,
    title: `progress of ${durationMinutes} minutes`,
    progressProps: {
      onChange,
      value,
      secondaryValue,
      leftCss: {
        backgroundColor: '$progressLeft'
      },
      middleCss: {
        backgroundColor: '$progressMiddle'
      },
      rightCss: {
        backgroundColor: '$progressRight'
      },
      thumbCss: {
        backgroundColor: '$progressThumb'
      },
      ...rest
    }
  };
};

const getFormattedHoursMinutesSeconds = valueInSeconds => {
  if (valueInSeconds !== undefined && valueInSeconds !== null && !isNaN(valueInSeconds) && isFinite(valueInSeconds)) {
    const roundedValue = Math.round(valueInSeconds);
    const hours = Math.floor(roundedValue / 3600);
    const seconds = Math.floor(roundedValue % 60);
    if (hours > 0) {
      const minutes = Math.floor(roundedValue % 3600 / 60);
      return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds < 10 ? '0' : ''}${seconds}`;
    }
    const minutes = Math.floor(roundedValue / 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }
  return `0:00`;
};

const useTimeDisplay = props => {
  const {
    duration,
    progress,
    live
  } = props;
  const formattedTimeDisplay = React.useMemo(() => getFormattedHoursMinutesSeconds(progress ?? null), [progress]);
  const formattedDuration = React.useMemo(() => getFormattedHoursMinutesSeconds(duration ?? null), [duration]);
  const formattedTime = React.useMemo(() => live ? formattedTimeDisplay : `${formattedTimeDisplay} / ${formattedDuration}`, [formattedTimeDisplay, formattedDuration, live]);
  return {
    title: formattedTime,
    live
  };
};

const useVolume = props => {
  const {
    unmutedIcon,
    mutedIcon,
    onPress,
    showSlider = true,
    defaultUnmutedIcon,
    defaultMutedIcon,
    requestVolume,
    requestToggleMute,
    isVolumeChangeSupported,
    muted,
    ...rest
  } = props;
  const onPressComposed = React.useCallback(async () => {
    await onPress?.();
    requestToggleMute();
  }, [onPress, requestToggleMute]);
  const _children = useConditionalIcon(!muted, unmutedIcon, defaultUnmutedIcon, mutedIcon, defaultMutedIcon);
  const title = React.useMemo(() => muted ? 'Unmute (m)' : 'Mute (m)', [muted]);
  const onChange = React.useCallback(async value => {
    requestVolume(value);
  }, [requestVolume]);
  return {
    title,
    buttonProps: {
      onPress: onPressComposed,
      children: _children,
      ...rest
    },
    progressProps: {
      shown: isVolumeChangeSupported && showSlider,
      onChange,
      leftCss: {
        backgroundColor: '$volumeLeft'
      },
      middleCss: {
        backgroundColor: '$volumeMiddle'
      },
      rightCss: {
        backgroundColor: '$volumeRight'
      },
      thumbCss: {
        backgroundColor: '$volumeThumb'
      }
    }
  };
};

/**
 * Retrieves the playback info for a playback ID or source URL.
 * Conditionally, automatically imports a source URL from IPFS or Arweave.
 *
 * @param src Source URL for the media.
 * @param playbackId Playback ID of the media.
 */
const usePlaybackInfoOrImport = ({
  decentralizedSrcOrPlaybackId,
  playbackId,
  refetchPlaybackInfoInterval,
  autoUrlUpload,
  onAssetStatusChange,
  playRecording
}) => {
  const {
    mutate: importAsset,
    status,
    progress
  } = useCreateAsset(decentralizedSrcOrPlaybackId ? {
    sources: [{
      name: decentralizedSrcOrPlaybackId.id,
      url: decentralizedSrcOrPlaybackId.url
    }]
  } : null);
  React.useEffect(() => {
    if (progress?.[0]) {
      onAssetStatusChange(progress[0]);
    }
  }, [progress, onAssetStatusChange]);
  const {
    data: playbackInfo,
    error: playbackInfoError
  } = usePlaybackInfo({
    // attempt to fetch if the source is from decentralized storage, or a playback ID is provided
    playbackId: decentralizedSrcOrPlaybackId?.id ?? playbackId ?? undefined,
    recordings: Boolean(playRecording),
    staleTime: 1_000 * 60 * 60 * 24,
    // 24 hours
    refetchInterval: info => info ? false : refetchPlaybackInfoInterval
  });
  const playbackInfoErrorCode = React.useMemo(() => playbackInfoError?.code, [playbackInfoError]);

  // trigger an import if the playback info had a 404 error and the asset is an IPFS source
  // also must be enabled
  React.useEffect(() => {
    if (autoUrlUpload && importAsset && status === 'idle' && playbackInfoErrorCode === 404) {
      importAsset();
    }
  }, [autoUrlUpload, playbackInfoErrorCode, importAsset, status]);
  return playbackInfo;
};

const defaultIpfsGateway = 'https://w3s.link';
const defaultArweaveGateway = 'https://arweave.net';
const SCREEN_WIDTH_MULTIPLIER = 2.5;
const useSourceMimeTyped = ({
  src,
  playbackId,
  jwt,
  refetchPlaybackInfoInterval,
  autoUrlUpload = {
    fallback: true
  },
  playbackInfo,
  screenWidth,
  accessKey,
  onAccessKeyRequest,
  playRecording,
  sessionToken
}) => {
  const [uploadStatus, setUploadStatus] = React.useState(null);
  const onAssetStatusChange = React.useCallback(status => {
    setUploadStatus(status);
  }, [setUploadStatus]);

  // check if the src or playbackId are decentralized storage sources (does not handle src arrays)
  const decentralizedSrcOrPlaybackId = React.useMemo(() => playbackId ? parseCid(playbackId) ?? parseArweaveTxId(playbackId) : !Array.isArray(src) ? parseCid(src) ?? parseArweaveTxId(src) : null, [playbackId, src]);
  const resolvedPlaybackInfo = usePlaybackInfoOrImport({
    decentralizedSrcOrPlaybackId,
    playbackId,
    refetchPlaybackInfoInterval,
    autoUrlUpload,
    onAssetStatusChange,
    playRecording
  });
  const combinedPlaybackInfo = React.useMemo(() => playbackInfo ?? resolvedPlaybackInfo, [playbackInfo, resolvedPlaybackInfo]);
  const fetchAccessKey = React.useCallback(async () => {
    if (accessKey) {
      return accessKey;
    }
    if (combinedPlaybackInfo?.meta?.playbackPolicy?.type === 'webhook') {
      const response = await onAccessKeyRequest?.(combinedPlaybackInfo.meta.playbackPolicy);
      return response ?? null;
    }
    return null;
  }, [accessKey, onAccessKeyRequest, combinedPlaybackInfo]);
  const {
    data: accessKeyResolved
  } = useInternalQuery({
    queryKey: [combinedPlaybackInfo, onAccessKeyRequest, accessKey],
    queryFn: fetchAccessKey,
    enabled: Boolean(combinedPlaybackInfo || accessKey),
    staleTime: Infinity
  });
  const [playbackUrls, setPlaybackUrls] = React.useState([]);
  React.useEffect(() => {
    const screenWidthWithDefault = (screenWidth ?? 1280) * SCREEN_WIDTH_MULTIPLIER;
    const recordingPlaybackSources = playRecording ? (playbackInfo ?? resolvedPlaybackInfo)?.meta?.dvrPlayback?.map(s => ({
      url: s?.url,
      screenWidthDelta: null,
      isRecording: true
    })) ?? [] : [];
    const playbackInfoSources = (playbackInfo ?? resolvedPlaybackInfo)?.meta?.source?.map(s => ({
      url: s?.url,
      screenWidthDelta: s?.width ? Math.abs(screenWidthWithDefault - s.width) : s?.url.includes('static360p') || s?.url.includes('low-bitrate') ? Math.abs(screenWidthWithDefault - 480) : s?.url.includes('static720p') ? Math.abs(screenWidthWithDefault - 1280) : s?.url.includes('static1080p') ? Math.abs(screenWidthWithDefault - 1920) : s?.url.includes('static2160p') ? Math.abs(screenWidthWithDefault - 3840) : null
    })) ?? [];
    const combinedPlaybackSources = [...recordingPlaybackSources, ...playbackInfoSources];
    if (combinedPlaybackSources.length) {
      setPlaybackUrls(combinedPlaybackSources);
    }
  }, [playbackInfo, resolvedPlaybackInfo, screenWidth, playRecording]);
  const dStoragePlaybackUrl = React.useMemo(() => {
    // if the player is auto uploading, we do not play back the detected input file unless specified
    // e.g. https://arweave.net/84KylA52FVGLxyvLADn1Pm8Q3kt8JJM74B87MeoBt2w/400019.mp4
    if (decentralizedSrcOrPlaybackId && autoUrlUpload) {
      const urlUploadWithFallback = typeof autoUrlUpload !== 'boolean' ? {
        arweaveGateway: autoUrlUpload.arweaveGateway ?? defaultArweaveGateway,
        ipfsGateway: autoUrlUpload.ipfsGateway ?? defaultIpfsGateway
      } : {
        arweaveGateway: defaultArweaveGateway,
        ipfsGateway: defaultIpfsGateway
      };
      if (decentralizedSrcOrPlaybackId.url.startsWith('ar://')) {
        const {
          host
        } = new URL(urlUploadWithFallback.arweaveGateway);
        const src = {
          type: 'video',
          mime: 'video/mp4',
          src: `https://${host}/${decentralizedSrcOrPlaybackId.id}`
        };
        return src;
      } else if (decentralizedSrcOrPlaybackId.url.startsWith('ipfs://')) {
        const {
          host
        } = new URL(urlUploadWithFallback.ipfsGateway);
        const src = {
          type: 'video',
          mime: 'video/mp4',
          src: `https://${host}/ipfs/${decentralizedSrcOrPlaybackId.id}`
        };
        return src;
      } else {
        const srcBase64 = {
          type: 'video',
          mime: 'video/mp4',
          src: src
        };
        return srcBase64;
      }
    }
    return null;
  }, [autoUrlUpload, decentralizedSrcOrPlaybackId, src]);
  const [type, sourceMimeTyped] = React.useMemo(() => {
    const defaultValue = ['none', null];

    // cast all URLs to an array of strings
    const sources = playbackUrls.length > 0 ? playRecording ? playbackUrls.filter(p => p.isRecording).map(p => p.url) : playbackUrls.map(p => p.url) : typeof src === 'string' ? [src] : src;
    if (!sources) {
      return defaultValue;
    }
    const mediaSourceTypes = sources.map(s => typeof s === 'string' ? getMediaSourceType(s) : null).filter(s => s);
    const authenticatedSources = mediaSourceTypes.map(source => {
      const url = new URL(source.src);

      // append the tkn to the query params
      if (sessionToken) {
        url.searchParams.append('tkn', sessionToken);
      }

      // we use headers for HLS and WebRTC for auth
      if (source.type === 'hls' || source.type === 'webrtc') {
        return {
          ...source,
          src: url.toString()
        };
      }

      // append the JWT to the query params
      if (jwt && source) {
        url.searchParams.append('jwt', jwt);
        return {
          ...source,
          src: url.toString()
        };
      }

      // append the access key to the query params
      if (accessKeyResolved && source) {
        url.searchParams.append('accessKey', accessKeyResolved);
        return {
          ...source,
          src: url.toString()
        };
      }
      return {
        ...source,
        src: url.toString()
      };
    });

    // we filter by either audio or video/hls
    return authenticatedSources?.[0]?.type === 'audio' ? ['audio', authenticatedSources.filter(s => s.type === 'audio')] : authenticatedSources?.[0]?.type === 'video' || authenticatedSources?.[0]?.type === 'hls' || authenticatedSources?.[0]?.type === 'webrtc' ? ['video', authenticatedSources.filter(s => s.type === 'video' || s.type === 'hls' || s.type === 'webrtc')] : defaultValue;
  }, [playbackUrls, src, playRecording]);
  const sourceMimeTypedSorted = React.useMemo(() => {
    // if there is no source mime type and the Player has dstorage fallback enabled,
    // we attempt to play from the dstorage URL directly
    if (!sourceMimeTyped && dStoragePlaybackUrl) {
      return [dStoragePlaybackUrl];
    }
    if (type === 'video') {
      const previousSources = [...sourceMimeTyped];
      return previousSources.sort((a, b) => {
        if (a.type === 'video' && b.type === 'video') {
          const aOriginal = playbackUrls.find(u => u.url === a.src);
          const bOriginal = playbackUrls.find(u => u.url === b.src);

          // we sort the sources by the delta between the video width and the
          // screen size (multiplied by a multiplier above)
          return bOriginal?.screenWidthDelta && aOriginal?.screenWidthDelta ? aOriginal.screenWidthDelta - bOriginal.screenWidthDelta : 1;
        } else if (a.type === 'video' && (b.type === 'hls' || b.type === 'webrtc')) {
          // if the type is an MP4, we prefer that to HLS/WebRTC due to better caching/less overhead
          return -1;
        } else if (a.type === 'webrtc' && b.type === 'hls') {
          // if there is a webrtc source, we prefer that to HLS
          return -1;
        }
        return 1;
      });
    }
    return sourceMimeTyped;
  }, [sourceMimeTyped, type, dStoragePlaybackUrl, playbackUrls]);
  return {
    source: sourceMimeTypedSorted,
    uploadStatus,
    accessKeyResolved,
    jwtResolved: jwt
  };
};

const usePlayer = ({
  autoPlay,
  children,
  controls,
  muted,
  playbackId,
  src,
  playbackInfo,
  theme,
  title,
  poster,
  loop,
  onStreamStatusChange,
  onAccessControlError,
  onError,
  onSourceUpdated,
  jwt,
  clipLength,
  onClipCreated,
  onClipError,
  onClipStarted,
  viewerId,
  refetchPlaybackInfoInterval = 5000,
  autoUrlUpload = true,
  accessKey,
  onAccessKeyRequest,
  showLoadingSpinner = true,
  showUploadingIndicator = true,
  showTitle = true,
  priority,
  aspectRatio = '16to9',
  objectFit = 'contain',
  mediaElementRef,
  _isCurrentlyShown,
  playRecording,
  onPlaybackStatusUpdate,
  playbackStatusSelector,
  playbackFailedErrorComponent,
  streamOfflineErrorComponent,
  accessControlErrorComponent,
  onPlaybackError: onPlaybackErrorProp,
  renderChildrenOutsideContainer
}, {
  _screenWidth
}) => {
  const [mediaElement, setMediaElement] = React.useState(null);
  const sessionToken = React.useMemo(() => generateRandomToken(), [playbackId]);
  const {
    source,
    uploadStatus,
    jwtResolved,
    accessKeyResolved
  } = useSourceMimeTyped({
    src,
    playbackId,
    jwt,
    refetchPlaybackInfoInterval,
    autoUrlUpload,
    screenWidth: _screenWidth,
    playbackInfo,
    accessKey,
    onAccessKeyRequest,
    playRecording,
    sessionToken
  });
  const [playbackError, setPlaybackError] = React.useState(null);
  const onPlaybackError = React.useCallback(error => {
    const newPlaybackError = error ? {
      type: isAccessControlError(error) ? 'access-control' : isBframesError(error) || isNotAcceptableError(error) ? 'fallback' : isStreamOfflineError(error) ? 'offline' : 'unknown',
      message: error?.message ?? 'Error with playback.'
    } : null;
    setPlaybackError(newPlaybackError);
    try {
      if (newPlaybackError) {
        console.log(newPlaybackError);
      }
      onPlaybackErrorProp?.(newPlaybackError);
      if (!error) {
        onStreamStatusChange?.(true);
      } else if (newPlaybackError?.type === 'offline') {
        onStreamStatusChange?.(false);
      } else if (newPlaybackError?.type === 'access-control') {
        onAccessControlError?.(new Error(newPlaybackError.message));
      } else if (newPlaybackError?.message) {
        onError?.(new Error(newPlaybackError.message));
      }
    } catch (e) {
      console.error(e);
    }
    return newPlaybackError;
  }, [onAccessControlError, onStreamStatusChange, onError, onPlaybackErrorProp]);
  React.useEffect(() => {
    if (source) {
      onSourceUpdated?.(source);
      setPlaybackError(null);
    }
  }, [source, onSourceUpdated]);

  // if the source is priority or currently shown on the screen, then load
  const [hasBeenShown, setHasBeenShown] = React.useState(false);
  const loaded = React.useMemo(() => priority || _isCurrentlyShown || hasBeenShown, [priority, _isCurrentlyShown, hasBeenShown]);
  React.useEffect(() => {
    if (_isCurrentlyShown && !hasBeenShown) {
      setHasBeenShown(true);
    }
  }, [_isCurrentlyShown, hasBeenShown]);
  const hidePosterOnPlayed = React.useMemo(() => Array.isArray(source) ? source?.[0]?.type !== 'audio' ? true : undefined : undefined, [source]);
  const playerRef = React.useCallback(element => {
    if (element) {
      setMediaElement(element);
      mediaElementRef?.(element);
    }
  }, [mediaElementRef]);
  const loadingText = React.useMemo(() => showUploadingIndicator ? uploadStatus?.phase === 'processing' && isNumber(uploadStatus?.progress) ? `Processing: ${(Number(uploadStatus?.progress) * 100).toFixed(0)}%` : uploadStatus?.phase === 'failed' ? 'Upload Failed' : null : null, [uploadStatus, showUploadingIndicator]);
  const playerProps = React.useMemo(() => ({
    ref: playerRef,
    autoPlay,
    playbackId,
    muted,
    poster: poster,
    loop: loop,
    objectFit: objectFit,
    options: controls,
    priority: priority,
    playbackError,
    onPlaybackError,
    isCurrentlyShown: _isCurrentlyShown,
    viewerId,
    onPlaybackStatusUpdate,
    playbackStatusSelector,
    jwt: jwtResolved,
    accessKey: accessKeyResolved
  }), [playerRef, playbackId, autoPlay, muted, poster, loop, objectFit, controls, priority, playbackError, onPlaybackError, _isCurrentlyShown, viewerId, onPlaybackStatusUpdate, playbackStatusSelector, jwtResolved, accessKeyResolved]);
  const mediaControllerProps = React.useMemo(() => ({
    autoPlay,
    playbackId: playbackId ?? undefined,
    muted,
    priority: priority,
    viewerId,
    clipLength,
    onClipCreated,
    onClipError,
    onClipStarted,
    sessionToken
  }), [autoPlay, playbackId, muted, priority, viewerId, clipLength, onClipCreated, onClipError, onClipStarted, sessionToken]);
  const controlsContainerProps = React.useMemo(() => ({
    hidePosterOnPlayed,
    showLoadingSpinner,
    loadingText,
    showUploadingIndicator,
    error: playbackError,
    playbackFailedErrorComponent,
    streamOfflineErrorComponent,
    accessControlErrorComponent
  }), [hidePosterOnPlayed, showLoadingSpinner, loadingText, showUploadingIndicator, playbackError, playbackFailedErrorComponent, streamOfflineErrorComponent, accessControlErrorComponent]);
  const props = React.useMemo(() => ({
    autoPlay,
    children,
    controls,
    playbackId,
    src,
    theme,
    title,
    poster,
    loop,
    jwt,
    refetchPlaybackInfoInterval,
    autoUrlUpload,
    showTitle,
    aspectRatio,
    objectFit,
    renderChildrenOutsideContainer,
    playbackError
  }), [autoPlay, children, controls, playbackId, src, theme, title, poster, loop, jwt, refetchPlaybackInfoInterval, autoUrlUpload, showTitle, aspectRatio, objectFit, renderChildrenOutsideContainer, playbackError]);
  const sourceWithLoaded = React.useMemo(() => loaded ? source : null, [loaded, source]);
  return {
    mediaElement,
    source: sourceWithLoaded,
    uploadStatus,
    playerProps,
    mediaControllerProps,
    controlsContainerProps,
    props
  };
};
const generateRandomToken = () => {
  try {
    return Math.random().toString(16).substring(2);
  } catch (e) {
    //
  }
  return 'none';
};

export { useBaseSlider, useBroadcast, useClipButton, useControlsContainer, useFullscreenButton, usePlayButton, usePlayer, useProgress, useTimeDisplay, useVolume };
