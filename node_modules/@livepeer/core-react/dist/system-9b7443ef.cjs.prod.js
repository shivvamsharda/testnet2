'use strict';

var actions = require('@livepeer/core/actions');
var React = require('react');
var useInternalQuery = require('./useInternalQuery-c049f707.cjs.prod.js');
var client = require('@livepeer/core/client');
var utils = require('@livepeer/core/utils');
var withSelector_js = require('use-sync-external-store/shim/with-selector.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function useLivepeerProvider() {
  return withSelector_js.useSyncExternalStoreWithSelector(cb => actions.watchLivepeerProvider(cb), () => actions.getLivepeerProvider(), () => actions.getLivepeerProvider(), x => x);
}

function useCreateAsset(options) {
  const livepeerProvider = useLivepeerProvider();
  const [progress, setProgress] = React.useState(undefined);
  const internalQuery = useInternalQuery.useInternalMutation(options, async args => actions.createAsset({
    ...args,
    onProgress: progress => setProgress(progress)
  }), [{
    entity: 'createAsset',
    livepeerProvider
  }]);
  return React.useMemo(() => ({
    ...internalQuery,
    progress
  }), [internalQuery, progress]);
}

const queryKey = (args, config) => [{
  entity: 'getPlaybackInfo',
  args,
  config
}];
function usePlaybackInfo(args) {
  const livepeerProvider = useLivepeerProvider();
  return useInternalQuery.useInternalQuery(getQueryParams(args, livepeerProvider));
}
async function prefetchPlaybackInfo(args, config) {
  const livepeerClient = client.createClient(config);
  return useInternalQuery.prefetchQuery(getQueryParams(args, livepeerClient.provider));
}
function getQueryParams(args, provider) {
  const getPlaybackInfoArgs = typeof args === 'string' ? args : {
    playbackId: args?.playbackId ?? ''
  };
  return {
    clearClient: args.clearClient,
    queryKey: queryKey(getPlaybackInfoArgs, provider.getConfig()),
    queryFn: async () => actions.getPlaybackInfo(args),
    enabled: Boolean(typeof args === 'string' ? args : args?.playbackId),
    ...(typeof args === 'object' ? utils.pick(args, ...useInternalQuery.usePickQueryKeys) : {})
  };
}

const useConditionalIcon = (conditional, truthyIcon, truthyDefaultIcon, falsyIcon, falsyDefaultIcon) => {
  const element = React__namespace.useMemo(() => conditional ? truthyIcon ?? truthyDefaultIcon : falsyIcon ?? falsyDefaultIcon, [conditional, truthyIcon, truthyDefaultIcon, falsyIcon, falsyDefaultIcon]);
  return React__namespace.useMemo(() => /*#__PURE__*/React__namespace.isValidElement(element) ? /*#__PURE__*/React__namespace.cloneElement(element) : null, [element]);
};
const useMemoizedIcon = (icon, defaultIcon) => {
  return React__namespace.useMemo(() => icon && /*#__PURE__*/React__namespace.isValidElement(icon) ? /*#__PURE__*/React__namespace.cloneElement(icon) : defaultIcon, [icon, defaultIcon]);
};

exports.prefetchPlaybackInfo = prefetchPlaybackInfo;
exports.useConditionalIcon = useConditionalIcon;
exports.useCreateAsset = useCreateAsset;
exports.useLivepeerProvider = useLivepeerProvider;
exports.useMemoizedIcon = useMemoizedIcon;
exports.usePlaybackInfo = usePlaybackInfo;
