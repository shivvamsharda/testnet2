'use strict';

var reactQuery = require('@tanstack/react-query');
var client_dist_livepeerCoreReactClient = require('./client-90c13eab.cjs.dev.js');
var core = require('@livepeer/core');
var React = require('react');
var LivepeerConfig = require('./LivepeerConfig-5a11a3d5.cjs.dev.js');

async function prefetchQuery(options) {
  try {
    const client = client_dist_livepeerCoreReactClient.defaultQueryClient();
    await client.prefetchQuery(options);
    const dehydratedState = reactQuery.dehydrate(client);
    if (options?.clearClient) {
      client.clear();
    }
    return dehydratedState;
  } catch (e) {
    console.warn(e);
    return {
      mutations: [],
      queries: []
    };
  }
}

const useInternalMutationKeys = ['cacheTime', 'networkMode', 'onError', 'onMutate', 'onSettled', 'onSuccess', 'retry', 'retryDelay', 'useErrorBoundary', 'meta'];
function useInternalMutation(options, mutationFn, mutationKey) {
  const {
    data,
    error,
    isError,
    isIdle,
    isLoading,
    isSuccess,
    mutate,
    mutateAsync,
    reset,
    variables,
    status
  } = reactQuery.useMutation(mutationFn, {
    context: LivepeerConfig.QueryClientContext,
    mutationKey: mutationKey,
    ...(typeof options?.mutationConfig === 'object' ? core.pick(options.mutationConfig, ...useInternalMutationKeys) : {}),
    useErrorBoundary: false
  });
  return React.useMemo(() => ({
    data,
    error,
    isError,
    isIdle,
    isLoading,
    isSuccess,
    mutate: options ? () => mutate({
      ...options,
      config: undefined
    }) : undefined,
    mutateAsync: () => options ? mutateAsync({
      ...options,
      config: undefined
    }) : undefined,
    variables,
    status,
    internal: {
      reset
    }
  }), [data, error, isError, isIdle, isLoading, isSuccess, mutate, mutateAsync, reset, variables, status, options]);
}

const usePickQueryKeys = ['cacheTime', 'enabled', 'networkMode', 'initialData', 'initialDataUpdatedAt', 'isDataEqual', 'keepPreviousData', 'meta', 'notifyOnChangeProps', 'onError', 'onSettled', 'onSuccess', 'placeholderData', 'refetchInterval', 'refetchIntervalInBackground', 'refetchOnMount', 'refetchOnReconnect', 'refetchOnWindowFocus', 'retry', 'retryOnMount', 'retryDelay', 'select', 'staleTime', 'structuralSharing', 'suspense', 'useErrorBoundary'];
function useInternalQuery(options) {
  const {
    data,
    dataUpdatedAt,
    error,
    errorUpdatedAt,
    failureCount,
    isError,
    isFetched,
    isFetchedAfterMount,
    isFetching,
    isPaused,
    isLoadingError,
    isPlaceholderData,
    isPreviousData,
    isRefetchError,
    isRefetching,
    isStale,
    isSuccess,
    refetch,
    remove,
    status: internalStatus,
    fetchStatus
  } = reactQuery.useQuery({
    ...options,
    context: LivepeerConfig.QueryClientContext
  });
  const status = React.useMemo(() => internalStatus === 'loading' && fetchStatus === 'idle' ? 'idle' : internalStatus, [internalStatus, fetchStatus]);
  const isIdle = React.useMemo(() => status === 'idle', [status]);
  const isLoading = React.useMemo(() => status === 'loading' && fetchStatus === 'fetching', [status, fetchStatus]);
  return {
    data,
    error,
    isError,
    isFetched,
    isFetching,
    isIdle,
    isLoading,
    isRefetching,
    isSuccess,
    refetch,
    status,
    internal: {
      fetchStatus,
      dataUpdatedAt,
      errorUpdatedAt,
      failureCount,
      isFetchedAfterMount,
      isLoadingError,
      isPaused,
      isPlaceholderData,
      isPreviousData,
      isRefetchError,
      isStale: isStale,
      remove
    }
  };
}

exports.prefetchQuery = prefetchQuery;
exports.useInternalMutation = useInternalMutation;
exports.useInternalMutationKeys = useInternalMutationKeys;
exports.useInternalQuery = useInternalQuery;
exports.usePickQueryKeys = usePickQueryKeys;
