import { dehydrate, useMutation, useQuery } from '@tanstack/react-query';
import { d as defaultQueryClient } from './client-c79d9b6b.esm.js';
import { pick } from '@livepeer/core';
import { useMemo } from 'react';
import { Q as QueryClientContext } from './LivepeerConfig-bc769187.esm.js';

async function prefetchQuery(options) {
  try {
    const client = defaultQueryClient();
    await client.prefetchQuery(options);
    const dehydratedState = dehydrate(client);
    if (options?.clearClient) {
      client.clear();
    }
    return dehydratedState;
  } catch (e) {
    console.warn(e);
    return {
      mutations: [],
      queries: []
    };
  }
}

const useInternalMutationKeys = ['cacheTime', 'networkMode', 'onError', 'onMutate', 'onSettled', 'onSuccess', 'retry', 'retryDelay', 'useErrorBoundary', 'meta'];
function useInternalMutation(options, mutationFn, mutationKey) {
  const {
    data,
    error,
    isError,
    isIdle,
    isLoading,
    isSuccess,
    mutate,
    mutateAsync,
    reset,
    variables,
    status
  } = useMutation(mutationFn, {
    context: QueryClientContext,
    mutationKey: mutationKey,
    ...(typeof options?.mutationConfig === 'object' ? pick(options.mutationConfig, ...useInternalMutationKeys) : {}),
    useErrorBoundary: false
  });
  return useMemo(() => ({
    data,
    error,
    isError,
    isIdle,
    isLoading,
    isSuccess,
    mutate: options ? () => mutate({
      ...options,
      config: undefined
    }) : undefined,
    mutateAsync: () => options ? mutateAsync({
      ...options,
      config: undefined
    }) : undefined,
    variables,
    status,
    internal: {
      reset
    }
  }), [data, error, isError, isIdle, isLoading, isSuccess, mutate, mutateAsync, reset, variables, status, options]);
}

const usePickQueryKeys = ['cacheTime', 'enabled', 'networkMode', 'initialData', 'initialDataUpdatedAt', 'isDataEqual', 'keepPreviousData', 'meta', 'notifyOnChangeProps', 'onError', 'onSettled', 'onSuccess', 'placeholderData', 'refetchInterval', 'refetchIntervalInBackground', 'refetchOnMount', 'refetchOnReconnect', 'refetchOnWindowFocus', 'retry', 'retryOnMount', 'retryDelay', 'select', 'staleTime', 'structuralSharing', 'suspense', 'useErrorBoundary'];
function useInternalQuery(options) {
  const {
    data,
    dataUpdatedAt,
    error,
    errorUpdatedAt,
    failureCount,
    isError,
    isFetched,
    isFetchedAfterMount,
    isFetching,
    isPaused,
    isLoadingError,
    isPlaceholderData,
    isPreviousData,
    isRefetchError,
    isRefetching,
    isStale,
    isSuccess,
    refetch,
    remove,
    status: internalStatus,
    fetchStatus
  } = useQuery({
    ...options,
    context: QueryClientContext
  });
  const status = useMemo(() => internalStatus === 'loading' && fetchStatus === 'idle' ? 'idle' : internalStatus, [internalStatus, fetchStatus]);
  const isIdle = useMemo(() => status === 'idle', [status]);
  const isLoading = useMemo(() => status === 'loading' && fetchStatus === 'fetching', [status, fetchStatus]);
  return {
    data,
    error,
    isError,
    isFetched,
    isFetching,
    isIdle,
    isLoading,
    isRefetching,
    isSuccess,
    refetch,
    status,
    internal: {
      fetchStatus,
      dataUpdatedAt,
      errorUpdatedAt,
      failureCount,
      isFetchedAfterMount,
      isLoadingError,
      isPaused,
      isPlaceholderData,
      isPreviousData,
      isRefetchError,
      isStale: isStale,
      remove
    }
  };
}

export { usePickQueryKeys as a, useInternalMutation as b, useInternalMutationKeys as c, prefetchQuery as p, useInternalQuery as u };
