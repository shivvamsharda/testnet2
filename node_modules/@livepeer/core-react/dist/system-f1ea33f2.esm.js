import { watchLivepeerProvider, getLivepeerProvider, createAsset, getPlaybackInfo } from '@livepeer/core/actions';
import * as React from 'react';
import { useState, useMemo } from 'react';
import { b as useInternalMutation, u as useInternalQuery, p as prefetchQuery, a as usePickQueryKeys } from './useInternalQuery-9e9dd997.esm.js';
import { createClient } from '@livepeer/core/client';
import { pick } from '@livepeer/core/utils';
import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js';

function useLivepeerProvider() {
  return useSyncExternalStoreWithSelector(cb => watchLivepeerProvider(cb), () => getLivepeerProvider(), () => getLivepeerProvider(), x => x);
}

function useCreateAsset(options) {
  const livepeerProvider = useLivepeerProvider();
  const [progress, setProgress] = useState(undefined);
  const internalQuery = useInternalMutation(options, async args => createAsset({
    ...args,
    onProgress: progress => setProgress(progress)
  }), [{
    entity: 'createAsset',
    livepeerProvider
  }]);
  return useMemo(() => ({
    ...internalQuery,
    progress
  }), [internalQuery, progress]);
}

const queryKey = (args, config) => [{
  entity: 'getPlaybackInfo',
  args,
  config
}];
function usePlaybackInfo(args) {
  const livepeerProvider = useLivepeerProvider();
  return useInternalQuery(getQueryParams(args, livepeerProvider));
}
async function prefetchPlaybackInfo(args, config) {
  const livepeerClient = createClient(config);
  return prefetchQuery(getQueryParams(args, livepeerClient.provider));
}
function getQueryParams(args, provider) {
  const getPlaybackInfoArgs = typeof args === 'string' ? args : {
    playbackId: args?.playbackId ?? ''
  };
  return {
    clearClient: args.clearClient,
    queryKey: queryKey(getPlaybackInfoArgs, provider.getConfig()),
    queryFn: async () => getPlaybackInfo(args),
    enabled: Boolean(typeof args === 'string' ? args : args?.playbackId),
    ...(typeof args === 'object' ? pick(args, ...usePickQueryKeys) : {})
  };
}

const useConditionalIcon = (conditional, truthyIcon, truthyDefaultIcon, falsyIcon, falsyDefaultIcon) => {
  const element = React.useMemo(() => conditional ? truthyIcon ?? truthyDefaultIcon : falsyIcon ?? falsyDefaultIcon, [conditional, truthyIcon, truthyDefaultIcon, falsyIcon, falsyDefaultIcon]);
  return React.useMemo(() => /*#__PURE__*/React.isValidElement(element) ? /*#__PURE__*/React.cloneElement(element) : null, [element]);
};
const useMemoizedIcon = (icon, defaultIcon) => {
  return React.useMemo(() => icon && /*#__PURE__*/React.isValidElement(icon) ? /*#__PURE__*/React.cloneElement(icon) : defaultIcon, [icon, defaultIcon]);
};

export { useCreateAsset as a, usePlaybackInfo as b, useConditionalIcon as c, useMemoizedIcon as d, prefetchPlaybackInfo as p, useLivepeerProvider as u };
