'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var asyncToGenerator = require('../../../../dist/asyncToGenerator-32d46645.cjs.prod.js');
require('core-js/modules/es.array.iterator.js');
require('core-js/modules/es.object.to-string.js');
require('core-js/modules/es.string.iterator.js');
require('core-js/modules/web.dom-collections.iterator.js');
require('core-js/modules/web.url.js');
require('core-js/modules/web.url-search-params.js');
require('core-js/modules/es.regexp.exec.js');
require('core-js/modules/es.string.match.js');
require('core-js/modules/es.string.replace.js');
require('core-js/modules/es.regexp.to-string.js');
require('core-js/modules/es.promise.js');
var core = require('@livepeer/core');
var fetch = require('cross-fetch');
var utils = require('../../../../dist/utils-5554bdd3.cjs.prod.js');
var createForOfIteratorHelper = require('../../../../dist/createForOfIteratorHelper-2539e6d8.cjs.prod.js');
require('core-js/modules/es.array.includes.js');
require('core-js/modules/es.string.includes.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var fetch__default = /*#__PURE__*/_interopDefault(fetch);

/**
 * Checks if WebRTC is supported.
 */
var isWebRTCSupported = function isWebRTCSupported() {
  var _window, _window2, _window3, _navigator, _navigator2, _navigator2$mediaDevi, _navigator3, _navigator4, _navigator5, _window4, _window5, _window6;
  if (!utils.isClient()) {
    return false;
  }
  var hasRTCPeerConnection = !!((_window = window) !== null && _window !== void 0 && _window.RTCPeerConnection || (_window2 = window) !== null && _window2 !== void 0 && _window2.webkitRTCPeerConnection || (_window3 = window) !== null && _window3 !== void 0 && _window3.mozRTCPeerConnection);
  var hasGetUserMedia = !!((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.getUserMedia || (_navigator2 = navigator) !== null && _navigator2 !== void 0 && (_navigator2$mediaDevi = _navigator2.mediaDevices) !== null && _navigator2$mediaDevi !== void 0 && _navigator2$mediaDevi.getUserMedia || (_navigator3 = navigator) !== null && _navigator3 !== void 0 && _navigator3.webkitGetUserMedia || (_navigator4 = navigator) !== null && _navigator4 !== void 0 && _navigator4.mozGetUserMedia || (_navigator5 = navigator) !== null && _navigator5 !== void 0 && _navigator5.msGetUserMedia);
  var hasRTCDataChannel = !!((_window4 = window) !== null && _window4 !== void 0 && _window4.RTCDataChannel || (_window5 = window) !== null && _window5 !== void 0 && _window5.webkitRTCDataChannel || (_window6 = window) !== null && _window6 !== void 0 && _window6.mozRTCDataChannel);
  return hasRTCPeerConnection && hasGetUserMedia && hasRTCDataChannel;
};
function createPeerConnection(host) {
  var _window7, _window8, _window9;
  var RTCPeerConnectionConstructor = ((_window7 = window) === null || _window7 === void 0 ? void 0 : _window7.RTCPeerConnection) || ((_window8 = window) === null || _window8 === void 0 ? void 0 : _window8.webkitRTCPeerConnection) || ((_window9 = window) === null || _window9 === void 0 ? void 0 : _window9.mozRTCPeerConnection);

  // strip non-standard port number if present
  var hostNoPort = host === null || host === void 0 ? void 0 : host.split(':')[0];
  var iceServers = host ? [{
    urls: "stun:".concat(hostNoPort)
  }, {
    urls: "turn:".concat(hostNoPort),
    username: 'livepeer',
    credential: 'livepeer'
  }] : [];
  if (RTCPeerConnectionConstructor) {
    return new RTCPeerConnectionConstructor({
      iceServers: iceServers
    });
  }
  return null;
}
var DEFAULT_TIMEOUT = 20000;

/**
 * Performs the actual SDP exchange.
 *
 * 1. Sends the SDP offer to the server,
 * 2. Awaits the server's offer.
 *
 * SDP describes what kind of media we can send and how the server and client communicate.
 *
 * https://developer.mozilla.org/en-US/docs/Glossary/SDP
 * https://www.ietf.org/archive/id/draft-ietf-wish-whip-01.html#name-protocol-operation
 */
function negotiateConnectionWithClientOffer(_x, _x2, _x3, _x4, _x5, _x6) {
  return _negotiateConnectionWithClientOffer.apply(this, arguments);
}

/**
 * Constructs the client's SDP offer
 *
 * SDP describes what kind of media we can send and how the server and client communicate.
 *
 * https://developer.mozilla.org/en-US/docs/Glossary/SDP
 * https://www.ietf.org/archive/id/draft-ietf-wish-whip-01.html#name-protocol-operation
 */
function _negotiateConnectionWithClientOffer() {
  _negotiateConnectionWithClientOffer = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee(peerConnection, endpoint, ofr, controller, config, accessControl) {
    var response, answerSDP, playheadUtc, errorMessage;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(peerConnection && endpoint && ofr)) {
              _context.next = 24;
              break;
            }
            _context.next = 3;
            return postSDPOffer(endpoint, ofr.sdp, controller, config, accessControl);
          case 3:
            response = _context.sent;
            if (!response.ok) {
              _context.next = 14;
              break;
            }
            _context.next = 7;
            return response.text();
          case 7:
            answerSDP = _context.sent;
            _context.next = 10;
            return peerConnection.setRemoteDescription(new RTCSessionDescription({
              type: 'answer',
              sdp: answerSDP
            }));
          case 10:
            playheadUtc = response.headers.get('Playhead-Utc');
            return _context.abrupt("return", new Date(playheadUtc !== null && playheadUtc !== void 0 ? playheadUtc : new Date()));
          case 14:
            if (!(response.status === 406)) {
              _context.next = 18;
              break;
            }
            throw new Error(core.NOT_ACCEPTABLE_ERROR_MESSAGE);
          case 18:
            _context.next = 20;
            return response.text();
          case 20:
            errorMessage = _context.sent;
            throw new Error(errorMessage);
          case 22:
            _context.next = 25;
            break;
          case 24:
            throw new Error('Peer connection not defined.');
          case 25:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _negotiateConnectionWithClientOffer.apply(this, arguments);
}
function constructClientOffer(_x7, _x8) {
  return _constructClientOffer.apply(this, arguments);
}

// Regular expression to match the playback ID at the end of the URL
// It looks for a string that follows the last "+" or "/" and continues to the end of the pathname
function _constructClientOffer() {
  _constructClientOffer = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee2(peerConnection, endpoint) {
    var offer, ofr;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(peerConnection && endpoint)) {
              _context2.next = 12;
              break;
            }
            _context2.next = 3;
            return peerConnection.createOffer();
          case 3:
            offer = _context2.sent;
            _context2.next = 6;
            return peerConnection.setLocalDescription(offer);
          case 6:
            _context2.next = 8;
            return waitToCompleteICEGathering(peerConnection);
          case 8:
            ofr = _context2.sent;
            if (ofr) {
              _context2.next = 11;
              break;
            }
            throw Error('failed to gather ICE candidates for offer');
          case 11:
            return _context2.abrupt("return", ofr);
          case 12:
            return _context2.abrupt("return", null);
          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _constructClientOffer.apply(this, arguments);
}
var playbackIdPattern = /([/+])([^/+?]+)$/;
var REPLACE_PLACEHOLDER = 'PLAYBACK_ID';
var cachedRedirectUrl = null;
function postSDPOffer(_x9, _x10, _x11, _x12, _x13) {
  return _postSDPOffer.apply(this, arguments);
}
function _postSDPOffer() {
  _postSDPOffer = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee3(endpoint, data, controller, config, accessControl) {
    var _config$sdpTimeout;
    var id, url, parsedMatches, clonedCachedUrl, response;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            id = setTimeout(function () {
              return controller.abort();
            }, (_config$sdpTimeout = config === null || config === void 0 ? void 0 : config.sdpTimeout) !== null && _config$sdpTimeout !== void 0 ? _config$sdpTimeout : DEFAULT_TIMEOUT);
            url = new URL(endpoint);
            parsedMatches = url.pathname.match(playbackIdPattern); // if we both have a cached redirect URL and a match for the playback ID,
            // use these to shortcut the typical webrtc redirect flow
            if (cachedRedirectUrl && parsedMatches !== null && parsedMatches !== void 0 && parsedMatches[2]) {
              clonedCachedUrl = new URL(cachedRedirectUrl);
              url.host = clonedCachedUrl.host;
              url.pathname = clonedCachedUrl.pathname.replace(REPLACE_PLACEHOLDER, parsedMatches[2]);
            }
            if (config !== null && config !== void 0 && config.constant) {
              url.searchParams.append('constant', 'true');
            }
            if (config !== null && config !== void 0 && config.audioTrackSelector) {
              url.searchParams.append('audio', config.audioTrackSelector);
            }
            if (config !== null && config !== void 0 && config.videoTrackSelector) {
              url.searchParams.append('video', config.videoTrackSelector);
            }
            _context3.next = 9;
            return fetch__default["default"](url.toString(), {
              method: 'POST',
              mode: 'cors',
              headers: asyncToGenerator._objectSpread2(asyncToGenerator._objectSpread2({
                'content-type': 'application/sdp'
              }, accessControl !== null && accessControl !== void 0 && accessControl.accessKey ? {
                'Livepeer-Access-Key': accessControl.accessKey
              } : {}), accessControl !== null && accessControl !== void 0 && accessControl.jwt ? {
                'Livepeer-Jwt': accessControl.jwt
              } : {}),
              body: data,
              signal: controller.signal
            });
          case 9:
            response = _context3.sent;
            clearTimeout(id);
            return _context3.abrupt("return", response);
          case 12:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _postSDPOffer.apply(this, arguments);
}
function getRedirectUrl(_x14, _x15, _x16) {
  return _getRedirectUrl.apply(this, arguments);
}

/**
 * Receives an RTCPeerConnection and waits until
 * the connection is initialized or a timeout passes.
 *
 * https://www.ietf.org/archive/id/draft-ietf-wish-whip-01.html#section-4.1
 * https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceGatheringState
 * https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event
 */
function _getRedirectUrl() {
  _getRedirectUrl = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee4(endpoint, abortController, timeout) {
    var inputUrl, id, response, parsedUrl, cachedUrl;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            if (!cachedRedirectUrl) {
              _context4.next = 5;
              break;
            }
            inputUrl = new URL(endpoint);
            inputUrl.host = cachedRedirectUrl.host;
            return _context4.abrupt("return", inputUrl);
          case 5:
            id = setTimeout(function () {
              return abortController.abort();
            }, timeout !== null && timeout !== void 0 ? timeout : DEFAULT_TIMEOUT);
            _context4.next = 8;
            return fetch__default["default"](endpoint, {
              method: 'HEAD',
              signal: abortController.signal
            });
          case 8:
            response = _context4.sent;
            clearTimeout(id);
            parsedUrl = new URL(response.url);
            if (parsedUrl) {
              cachedUrl = new URL(parsedUrl);
              cachedUrl.pathname = cachedUrl.pathname.replace(playbackIdPattern, "$1".concat(REPLACE_PLACEHOLDER));
              cachedRedirectUrl = cachedUrl;
            }
            return _context4.abrupt("return", parsedUrl);
          case 15:
            _context4.prev = 15;
            _context4.t0 = _context4["catch"](0);
            return _context4.abrupt("return", null);
          case 18:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[0, 15]]);
  }));
  return _getRedirectUrl.apply(this, arguments);
}
function waitToCompleteICEGathering(_x17) {
  return _waitToCompleteICEGathering.apply(this, arguments);
}
/**
 * Parses the ICE servers from the `Link` headers returned during SDP negotiation.
 */
// function parseIceServersFromLinkHeader(
//   iceString: string | null,
// ): NonNullable<RTCConfiguration['iceServers']> | null {
//   try {
//     const servers = iceString
//       ?.split(', ')
//       .map((serverStr) => {
//         const parts = serverStr.split('; ');
//         const server: NonNullable<RTCConfiguration['iceServers']>[number] = {
//           urls: '',
//         };
//         for (const part of parts) {
//           if (part.startsWith('stun:') || part.startsWith('turn:')) {
//             server.urls = part;
//           } else if (part.startsWith('username=')) {
//             server.username = part.slice('username="'.length, -1);
//           } else if (part.startsWith('credential=')) {
//             server.credential = part.slice('credential="'.length, -1);
//           }
//         }
//         return server;
//       })
//       .filter((server) => server.urls);
//     return servers && (servers?.length ?? 0) > 0 ? servers : null;
//   } catch (e) {
//     console.error(e);
//   }
//   return null;
// }
function _waitToCompleteICEGathering() {
  _waitToCompleteICEGathering = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee5(peerConnection) {
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            return _context5.abrupt("return", new Promise(function (resolve) {
              /** Wait at most five seconds for ICE gathering. */
              setTimeout(function () {
                resolve(peerConnection.localDescription);
              }, 5000);
              peerConnection.onicegatheringstatechange = function (_ev) {
                if (peerConnection.iceGatheringState === 'complete') {
                  resolve(peerConnection.localDescription);
                }
              };
            }));
          case 1:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _waitToCompleteICEGathering.apply(this, arguments);
}

/**
 * Client that uses WHEP to play back video over WebRTC.
 *
 * https://www.ietf.org/id/draft-murillo-whep-00.html
 */
var createNewWHEP = function createNewWHEP(source, element, callbacks, config, accessControl) {
  var destroyed = false;
  var abortController = new AbortController();
  var peerConnection = null;
  var stream = new MediaStream();
  var errorComposed = function errorComposed(e) {
    var _callbacks$onError;
    if (element) {
      element.srcObject = null;
    }
    callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onError = callbacks.onError) === null || _callbacks$onError === void 0 ? void 0 : _callbacks$onError.call(callbacks, e);
  };
  getRedirectUrl(source, abortController, config === null || config === void 0 ? void 0 : config.sdpTimeout).then(function (redirectUrl) {
    var _callbacks$onRedirect;
    if (destroyed || !redirectUrl) {
      return;
    }
    var redirectUrlString = redirectUrl.toString();
    callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onRedirect = callbacks.onRedirect) === null || _callbacks$onRedirect === void 0 ? void 0 : _callbacks$onRedirect.call(callbacks, redirectUrlString !== null && redirectUrlString !== void 0 ? redirectUrlString : null);

    /**
     * Create a new WebRTC connection, using public STUN servers with ICE,
     * allowing the client to discover its own IP address.
     * https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#ice
     */
    peerConnection = createPeerConnection(redirectUrl.host);
    if (peerConnection) {
      /** https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addTransceiver */
      peerConnection.addTransceiver('video', {
        direction: 'recvonly'
      });
      peerConnection.addTransceiver('audio', {
        direction: 'recvonly'
      });

      /**
       * When new tracks are received in the connection, store local references,
       * so that they can be added to a MediaStream, and to the <video> element.
       *
       * https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/track_event
       */
      peerConnection.ontrack = /*#__PURE__*/function () {
        var _ref = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee(event) {
          var track, currentTracks, streamAlreadyHasVideoTrack, streamAlreadyHasAudioTrack;
          return asyncToGenerator._regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  if (!stream) {
                    _context.next = 18;
                    break;
                  }
                  track = event.track;
                  currentTracks = stream.getTracks();
                  streamAlreadyHasVideoTrack = currentTracks.some(function (track) {
                    return track.kind === 'video';
                  });
                  streamAlreadyHasAudioTrack = currentTracks.some(function (track) {
                    return track.kind === 'audio';
                  });
                  _context.t0 = track.kind;
                  _context.next = _context.t0 === 'video' ? 9 : _context.t0 === 'audio' ? 13 : 17;
                  break;
                case 9:
                  if (!streamAlreadyHasVideoTrack) {
                    _context.next = 11;
                    break;
                  }
                  return _context.abrupt("break", 18);
                case 11:
                  stream.addTrack(track);
                  return _context.abrupt("break", 18);
                case 13:
                  if (!streamAlreadyHasAudioTrack) {
                    _context.next = 15;
                    break;
                  }
                  return _context.abrupt("break", 18);
                case 15:
                  stream.addTrack(track);
                  return _context.abrupt("break", 18);
                case 17:
                  console.log('got unknown track ' + track);
                case 18:
                  _context.next = 23;
                  break;
                case 20:
                  _context.prev = 20;
                  _context.t1 = _context["catch"](0);
                  errorComposed(_context.t1);
                case 23:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 20]]);
        }));
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }();
      peerConnection.addEventListener('connectionstatechange', /*#__PURE__*/function () {
        var _ref2 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee2(_ev) {
          var _peerConnection, _peerConnection2, _callbacks$onConnecte;
          return asyncToGenerator._regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  if (!(((_peerConnection = peerConnection) === null || _peerConnection === void 0 ? void 0 : _peerConnection.connectionState) === 'failed')) {
                    _context2.next = 3;
                    break;
                  }
                  throw new Error('Failed to connect to peer.');
                case 3:
                  if (((_peerConnection2 = peerConnection) === null || _peerConnection2 === void 0 ? void 0 : _peerConnection2.connectionState) === 'connected' && !element.srcObject) {
                    element.srcObject = stream;
                    callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onConnecte = callbacks.onConnected) === null || _callbacks$onConnecte === void 0 ? void 0 : _callbacks$onConnecte.call(callbacks);
                  }
                  _context2.next = 9;
                  break;
                case 6:
                  _context2.prev = 6;
                  _context2.t0 = _context2["catch"](0);
                  errorComposed(_context2.t0);
                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[0, 6]]);
        }));
        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }());
      peerConnection.addEventListener('negotiationneeded', /*#__PURE__*/function () {
        var _ref3 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee3(_ev) {
          var ofr, response, currentDate, _callbacks$onPlayback;
          return asyncToGenerator._regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.prev = 0;
                  _context3.next = 3;
                  return constructClientOffer(peerConnection, redirectUrlString);
                case 3:
                  ofr = _context3.sent;
                  _context3.next = 6;
                  return negotiateConnectionWithClientOffer(peerConnection, source, ofr, abortController, config, accessControl);
                case 6:
                  response = _context3.sent;
                  currentDate = Date.now();
                  if (response && currentDate) {
                    callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onPlayback = callbacks.onPlaybackOffsetUpdated) === null || _callbacks$onPlayback === void 0 ? void 0 : _callbacks$onPlayback.call(callbacks, currentDate - response.getTime());
                  }
                  _context3.next = 14;
                  break;
                case 11:
                  _context3.prev = 11;
                  _context3.t0 = _context3["catch"](0);
                  errorComposed(_context3.t0);
                case 14:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, null, [[0, 11]]);
        }));
        return function (_x3) {
          return _ref3.apply(this, arguments);
        };
      }());
    }
  }).catch(function (e) {
    return errorComposed(e);
  });
  return {
    destroy: function destroy() {
      var _abortController$abor, _peerConnection3, _peerConnection3$clos;
      destroyed = true;
      abortController === null || abortController === void 0 ? void 0 : (_abortController$abor = abortController.abort) === null || _abortController$abor === void 0 ? void 0 : _abortController$abor.call(abortController);

      // Remove the WebRTC source
      if (element) {
        element.srcObject = null;
      }
      (_peerConnection3 = peerConnection) === null || _peerConnection3 === void 0 ? void 0 : (_peerConnection3$clos = _peerConnection3.close) === null || _peerConnection3$clos === void 0 ? void 0 : _peerConnection3$clos.call(_peerConnection3);
    }
  };
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

/**
 * Client that uses WHIP to broadcast video over WebRTC.
 *
 * https://www.ietf.org/archive/id/draft-ietf-wish-whip-01.html
 */
var createNewWHIP = function createNewWHIP(ingestUrl, element, aspectRatio, callbacks, config, accessControl) {
  var destroyed = false;
  var abortController = new AbortController();
  var peerConnection = null;
  var stream = null;
  var videoTransceiver = null;
  var audioTransceiver = null;
  getRedirectUrl(ingestUrl, abortController, config === null || config === void 0 ? void 0 : config.sdpTimeout).then(function (redirectUrl) {
    if (destroyed || !redirectUrl) {
      return;
    }
    var redirectUrlString = redirectUrl.toString().replace('video+', '');

    /**
     * Create a new WebRTC connection, using public STUN servers with ICE,
     * allowing the client to discover its own IP address.
     * https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#ice
     */
    peerConnection = createPeerConnection(redirectUrl.host);
    if (peerConnection) {
      peerConnection.addEventListener('negotiationneeded', /*#__PURE__*/function () {
        var _ref = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee(_ev) {
          var ofr, _callbacks$onError;
          return asyncToGenerator._regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return constructClientOffer(peerConnection, redirectUrlString);
                case 3:
                  ofr = _context.sent;
                  _context.next = 6;
                  return negotiateConnectionWithClientOffer(peerConnection, ingestUrl, ofr, abortController, config, accessControl);
                case 6:
                  _context.next = 11;
                  break;
                case 8:
                  _context.prev = 8;
                  _context.t0 = _context["catch"](0);
                  callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onError = callbacks.onError) === null || _callbacks$onError === void 0 ? void 0 : _callbacks$onError.call(callbacks, _context.t0);
                case 11:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 8]]);
        }));
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
      peerConnection.addEventListener('connectionstatechange', /*#__PURE__*/function () {
        var _ref2 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee2(_ev) {
          var _peerConnection, _peerConnection2, _callbacks$onConnecte, _callbacks$onError2;
          return asyncToGenerator._regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  if (!(((_peerConnection = peerConnection) === null || _peerConnection === void 0 ? void 0 : _peerConnection.connectionState) === 'failed')) {
                    _context2.next = 3;
                    break;
                  }
                  throw new Error('Failed to connect to peer.');
                case 3:
                  if (((_peerConnection2 = peerConnection) === null || _peerConnection2 === void 0 ? void 0 : _peerConnection2.connectionState) === 'connected' && stream && audioTransceiver && videoTransceiver) {
                    element.srcObject = stream;
                    callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onConnecte = callbacks.onConnected) === null || _callbacks$onConnecte === void 0 ? void 0 : _callbacks$onConnecte.call(callbacks, {
                      stream: stream,
                      videoTransceiver: videoTransceiver,
                      audioTransceiver: audioTransceiver
                    });
                  }
                  _context2.next = 9;
                  break;
                case 6:
                  _context2.prev = 6;
                  _context2.t0 = _context2["catch"](0);
                  callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onError2 = callbacks.onError) === null || _callbacks$onError2 === void 0 ? void 0 : _callbacks$onError2.call(callbacks, _context2.t0);
                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[0, 6]]);
        }));
        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }());

      /**
       * While the connection is being initialized, ask for camera and microphone permissions and
       * add video and audio tracks to the peerConnection.
       *
       * https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
       */
      navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      }).then( /*#__PURE__*/function () {
        var _ref3 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee3(mediaStream) {
          var _mediaStream$getVideo, _mediaStream$getVideo2, _mediaStream$getVideo3, _mediaStream$getAudio, _mediaStream$getAudio2, _mediaStream$getAudio3;
          var newVideoTrack, newAudioTrack, _peerConnection$addTr, _peerConnection3, _peerConnection$addTr2, _peerConnection4;
          return asyncToGenerator._regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  newVideoTrack = (_mediaStream$getVideo = mediaStream === null || mediaStream === void 0 ? void 0 : (_mediaStream$getVideo2 = mediaStream.getVideoTracks) === null || _mediaStream$getVideo2 === void 0 ? void 0 : (_mediaStream$getVideo3 = _mediaStream$getVideo2.call(mediaStream)) === null || _mediaStream$getVideo3 === void 0 ? void 0 : _mediaStream$getVideo3[0]) !== null && _mediaStream$getVideo !== void 0 ? _mediaStream$getVideo : null;
                  newAudioTrack = (_mediaStream$getAudio = mediaStream === null || mediaStream === void 0 ? void 0 : (_mediaStream$getAudio2 = mediaStream.getAudioTracks) === null || _mediaStream$getAudio2 === void 0 ? void 0 : (_mediaStream$getAudio3 = _mediaStream$getAudio2.call(mediaStream)) === null || _mediaStream$getAudio3 === void 0 ? void 0 : _mediaStream$getAudio3[0]) !== null && _mediaStream$getAudio !== void 0 ? _mediaStream$getAudio : null;
                  if (!newVideoTrack) {
                    _context3.next = 6;
                    break;
                  }
                  _context3.next = 5;
                  return newVideoTrack.applyConstraints(getConstraints(aspectRatio !== null && aspectRatio !== void 0 ? aspectRatio : '16to9'));
                case 5:
                  videoTransceiver = (_peerConnection$addTr = (_peerConnection3 = peerConnection) === null || _peerConnection3 === void 0 ? void 0 : _peerConnection3.addTransceiver(newVideoTrack, {
                    direction: 'sendonly'
                  })) !== null && _peerConnection$addTr !== void 0 ? _peerConnection$addTr : null;
                case 6:
                  if (newAudioTrack) {
                    audioTransceiver = (_peerConnection$addTr2 = (_peerConnection4 = peerConnection) === null || _peerConnection4 === void 0 ? void 0 : _peerConnection4.addTransceiver(newAudioTrack, {
                      direction: 'sendonly'
                    })) !== null && _peerConnection$addTr2 !== void 0 ? _peerConnection$addTr2 : null;
                  }
                  stream = mediaStream;
                case 8:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));
        return function (_x3) {
          return _ref3.apply(this, arguments);
        };
      }()).catch(function (e) {
        var _callbacks$onError3;
        return callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onError3 = callbacks.onError) === null || _callbacks$onError3 === void 0 ? void 0 : _callbacks$onError3.call(callbacks, e);
      });
    }
  }).catch(function (e) {
    var _callbacks$onError4;
    return callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onError4 = callbacks.onError) === null || _callbacks$onError4 === void 0 ? void 0 : _callbacks$onError4.call(callbacks, e);
  });
  return {
    destroy: function destroy() {
      var _abortController$abor, _peerConnection5, _peerConnection5$clos, _stream$getTracks, _stream, _stream$getTracks2;
      destroyed = true;
      abortController === null || abortController === void 0 ? void 0 : (_abortController$abor = abortController.abort) === null || _abortController$abor === void 0 ? void 0 : _abortController$abor.call(abortController);

      // Remove the WebRTC source
      if (element) {
        element.srcObject = null;
      }
      (_peerConnection5 = peerConnection) === null || _peerConnection5 === void 0 ? void 0 : (_peerConnection5$clos = _peerConnection5.close) === null || _peerConnection5$clos === void 0 ? void 0 : _peerConnection5$clos.call(_peerConnection5);

      // Stop using the local camera and microphone
      var tracks = (_stream$getTracks = (_stream = stream) === null || _stream === void 0 ? void 0 : (_stream$getTracks2 = _stream.getTracks) === null || _stream$getTracks2 === void 0 ? void 0 : _stream$getTracks2.call(_stream)) !== null && _stream$getTracks !== void 0 ? _stream$getTracks : [];
      var _iterator = createForOfIteratorHelper._createForOfIteratorHelper(tracks),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _track$stop;
          var track = _step.value;
          track === null || track === void 0 ? void 0 : (_track$stop = track.stop) === null || _track$stop === void 0 ? void 0 : _track$stop.call(track);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  };
};

/**
 * Ask for camera and microphone permissions and add video and audio tracks to the peerConnection.
 * If a media stream is passed in, use this for the connection.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
 */
var changeMediaStream = /*#__PURE__*/function () {
  var _ref5 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee4(_ref4) {
    var _prevMediaStream$getV, _prevMediaStream$getV2, _prevMediaStream$getV3, _prevMediaStream$getA, _prevMediaStream$getA2, _prevMediaStream$getA3, _newMediaStream$getVi, _newMediaStream$getVi2, _newMediaStream$getVi3, _newMediaStream$getAu, _newMediaStream$getAu2, _newMediaStream$getAu3;
    var newMediaStream, prevMediaStream, aspectRatio, element, onConnected, videoTransceiver, audioTransceiver, prevVideoTrack, prevAudioTrack, newVideoTrack, newAudioTrack, _prevVideoTrack$enabl, _prevAudioTrack$enabl;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            newMediaStream = _ref4.newMediaStream, prevMediaStream = _ref4.prevMediaStream, aspectRatio = _ref4.aspectRatio, element = _ref4.element, onConnected = _ref4.onConnected, videoTransceiver = _ref4.videoTransceiver, audioTransceiver = _ref4.audioTransceiver;
            prevVideoTrack = (_prevMediaStream$getV = prevMediaStream === null || prevMediaStream === void 0 ? void 0 : (_prevMediaStream$getV2 = prevMediaStream.getVideoTracks) === null || _prevMediaStream$getV2 === void 0 ? void 0 : (_prevMediaStream$getV3 = _prevMediaStream$getV2.call(prevMediaStream)) === null || _prevMediaStream$getV3 === void 0 ? void 0 : _prevMediaStream$getV3[0]) !== null && _prevMediaStream$getV !== void 0 ? _prevMediaStream$getV : null;
            prevAudioTrack = (_prevMediaStream$getA = prevMediaStream === null || prevMediaStream === void 0 ? void 0 : (_prevMediaStream$getA2 = prevMediaStream.getAudioTracks) === null || _prevMediaStream$getA2 === void 0 ? void 0 : (_prevMediaStream$getA3 = _prevMediaStream$getA2.call(prevMediaStream)) === null || _prevMediaStream$getA3 === void 0 ? void 0 : _prevMediaStream$getA3[0]) !== null && _prevMediaStream$getA !== void 0 ? _prevMediaStream$getA : null;
            newVideoTrack = (_newMediaStream$getVi = newMediaStream === null || newMediaStream === void 0 ? void 0 : (_newMediaStream$getVi2 = newMediaStream.getVideoTracks) === null || _newMediaStream$getVi2 === void 0 ? void 0 : (_newMediaStream$getVi3 = _newMediaStream$getVi2.call(newMediaStream)) === null || _newMediaStream$getVi3 === void 0 ? void 0 : _newMediaStream$getVi3[0]) !== null && _newMediaStream$getVi !== void 0 ? _newMediaStream$getVi : null;
            newAudioTrack = (_newMediaStream$getAu = newMediaStream === null || newMediaStream === void 0 ? void 0 : (_newMediaStream$getAu2 = newMediaStream.getAudioTracks) === null || _newMediaStream$getAu2 === void 0 ? void 0 : (_newMediaStream$getAu3 = _newMediaStream$getAu2.call(newMediaStream)) === null || _newMediaStream$getAu3 === void 0 ? void 0 : _newMediaStream$getAu3[0]) !== null && _newMediaStream$getAu !== void 0 ? _newMediaStream$getAu : null;
            if (!newVideoTrack) {
              _context4.next = 11;
              break;
            }
            _context4.next = 8;
            return newVideoTrack.applyConstraints(getConstraints(aspectRatio));
          case 8:
            _context4.next = 10;
            return videoTransceiver.sender.replaceTrack(newVideoTrack);
          case 10:
            newVideoTrack.enabled = (_prevVideoTrack$enabl = prevVideoTrack === null || prevVideoTrack === void 0 ? void 0 : prevVideoTrack.enabled) !== null && _prevVideoTrack$enabl !== void 0 ? _prevVideoTrack$enabl : true;
          case 11:
            if (!newAudioTrack) {
              _context4.next = 15;
              break;
            }
            _context4.next = 14;
            return audioTransceiver.sender.replaceTrack(newAudioTrack);
          case 14:
            newAudioTrack.enabled = (_prevAudioTrack$enabl = prevAudioTrack === null || prevAudioTrack === void 0 ? void 0 : prevAudioTrack.enabled) !== null && _prevAudioTrack$enabl !== void 0 ? _prevAudioTrack$enabl : true;
          case 15:
            element.srcObject = newMediaStream;
            onConnected({
              stream: newMediaStream,
              videoTransceiver: videoTransceiver,
              audioTransceiver: audioTransceiver
            });
          case 17:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return function changeMediaStream(_x4) {
    return _ref5.apply(this, arguments);
  };
}();

/**
 * Ask for camera and microphone permissions and get the MediaStream for the given constraints.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
 */
var getUserMedia = /*#__PURE__*/function () {
  var _ref7 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee5(_ref6) {
    var source, _navigator, _navigator$mediaDevic, _source$streamConstra, _source$streamConstra2, _source$streamConstra3, _source$streamConstra4, newMediaStream;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            source = _ref6.source;
            _context5.prev = 1;
            _context5.next = 4;
            return (_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator$mediaDevic = _navigator.mediaDevices) === null || _navigator$mediaDevic === void 0 ? void 0 : _navigator$mediaDevic.getUserMedia(asyncToGenerator._objectSpread2(asyncToGenerator._objectSpread2({}, _typeof(source.streamConstraints) === 'object' ? source.streamConstraints : {}), {}, {
              video: asyncToGenerator._objectSpread2(asyncToGenerator._objectSpread2({}, typeof ((_source$streamConstra = source.streamConstraints) === null || _source$streamConstra === void 0 ? void 0 : _source$streamConstra.video) !== 'boolean' ? (_source$streamConstra2 = source.streamConstraints) === null || _source$streamConstra2 === void 0 ? void 0 : _source$streamConstra2.video : {}), source !== null && source !== void 0 && source.videoDeviceId ? {
                deviceId: source === null || source === void 0 ? void 0 : source.videoDeviceId
              } : {}),
              audio: asyncToGenerator._objectSpread2(asyncToGenerator._objectSpread2({}, typeof ((_source$streamConstra3 = source.streamConstraints) === null || _source$streamConstra3 === void 0 ? void 0 : _source$streamConstra3.audio) !== 'boolean' ? (_source$streamConstra4 = source.streamConstraints) === null || _source$streamConstra4 === void 0 ? void 0 : _source$streamConstra4.audio : {}), source !== null && source !== void 0 && source.audioDeviceId ? {
                deviceId: source === null || source === void 0 ? void 0 : source.audioDeviceId
              } : {})
            }));
          case 4:
            newMediaStream = _context5.sent;
            return _context5.abrupt("return", newMediaStream !== null && newMediaStream !== void 0 ? newMediaStream : null);
          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](1);
            console.error(_context5.t0);
            return _context5.abrupt("return", null);
          case 12:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[1, 8]]);
  }));
  return function getUserMedia(_x5) {
    return _ref7.apply(this, arguments);
  };
}();
var getMediaDevices = function getMediaDevices(onDevicesUpdated) {
  var _navigator2, _navigator2$mediaDevi;
  if (typeof navigator !== 'undefined' && (_navigator2 = navigator) !== null && _navigator2 !== void 0 && (_navigator2$mediaDevi = _navigator2.mediaDevices) !== null && _navigator2$mediaDevi !== void 0 && _navigator2$mediaDevi.enumerateDevices) {
    var onDeviceChange = function onDeviceChange() {
      navigator.mediaDevices.enumerateDevices().then(function (devices) {
        return onDevicesUpdated(devices);
      });
    };
    navigator.mediaDevices.addEventListener('devicechange', onDeviceChange);
    onDeviceChange();
    return function () {
      navigator.mediaDevices.removeEventListener('devicechange', onDeviceChange);
    };
  }
  return function () {
    //
  };
};
var getDisplayMedia = /*#__PURE__*/function () {
  var _ref8 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee6(options) {
    var _navigator3, _navigator3$mediaDevi, mediaStream;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.prev = 0;
            if (!(typeof navigator !== 'undefined' && (_navigator3 = navigator) !== null && _navigator3 !== void 0 && (_navigator3$mediaDevi = _navigator3.mediaDevices) !== null && _navigator3$mediaDevi !== void 0 && _navigator3$mediaDevi.getDisplayMedia)) {
              _context6.next = 6;
              break;
            }
            _context6.next = 4;
            return navigator.mediaDevices.getDisplayMedia(options);
          case 4:
            mediaStream = _context6.sent;
            return _context6.abrupt("return", mediaStream);
          case 6:
            _context6.next = 11;
            break;
          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](0);
            console.error(_context6.t0);
          case 11:
            return _context6.abrupt("return", null);
          case 12:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[0, 8]]);
  }));
  return function getDisplayMedia(_x6) {
    return _ref8.apply(this, arguments);
  };
}();
var getConstraints = function getConstraints(aspectRatio) {
  var constraints = {
    width: {
      ideal: 1280
    },
    height: {
      ideal: 720
    },
    aspectRatio: {
      ideal: aspectRatio === '9to16' ? 9 / 16 : aspectRatio === '1to1' ? 1 : aspectRatio === '21to9' ? 21 / 9 : aspectRatio === '4to5' ? 4 / 5 : 16 / 9
    }
  };
  return constraints;
};

exports.changeMediaStream = changeMediaStream;
exports.createNewWHEP = createNewWHEP;
exports.createNewWHIP = createNewWHIP;
exports.getDisplayMedia = getDisplayMedia;
exports.getMediaDevices = getMediaDevices;
exports.getUserMedia = getUserMedia;
exports.isWebRTCSupported = isWebRTCSupported;
