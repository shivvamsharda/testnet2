{"version":3,"file":"index.production.js","sources":["../../src/asyncThrottle.ts","../../src/index.ts"],"sourcesContent":["export interface AsyncThrottleOptions {\n  interval?: number\n  onError?: (error: unknown) => void\n}\n\nconst noop = () => {\n  /* do nothing */\n}\n\nexport function asyncThrottle<Args extends readonly unknown[]>(\n  func: (...args: Args) => Promise<void>,\n  { interval = 1000, onError = noop }: AsyncThrottleOptions = {},\n) {\n  if (typeof func !== 'function') throw new Error('argument is not function.')\n\n  let running = false\n  let lastTime = 0\n  let timeout: ReturnType<typeof setTimeout>\n  let currentArgs: Args | null = null\n\n  const execFunc = async () => {\n    if (currentArgs) {\n      const args = currentArgs\n      currentArgs = null\n      try {\n        running = true\n        await func(...args)\n      } catch (error) {\n        onError(error)\n      } finally {\n        lastTime = Date.now() // this line must after 'func' executed to avoid two 'func' running in concurrent.\n        running = false\n      }\n    }\n  }\n\n  const delayFunc = async () => {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => {\n      if (running) {\n        delayFunc() // Will come here when 'func' execution time is greater than the interval.\n      } else {\n        execFunc()\n      }\n    }, interval)\n  }\n\n  return (...args: Args) => {\n    currentArgs = args\n\n    const tooSoon = Date.now() - lastTime < interval\n    if (running || tooSoon) {\n      delayFunc()\n    } else {\n      execFunc()\n    }\n  }\n}\n","import type {\n  PersistedClient,\n  Persister,\n  Promisable,\n} from '@tanstack/query-persist-client-core'\nimport { asyncThrottle } from './asyncThrottle'\n\ninterface AsyncStorage {\n  getItem: (key: string) => Promise<string | null>\n  setItem: (key: string, value: string) => Promise<unknown>\n  removeItem: (key: string) => Promise<void>\n}\n\nexport type AsyncPersistRetryer = (props: {\n  persistedClient: PersistedClient\n  error: Error\n  errorCount: number\n}) => Promisable<PersistedClient | undefined>\n\ninterface CreateAsyncStoragePersisterOptions {\n  /** The storage client used for setting and retrieving items from cache.\n   * For SSR pass in `undefined`. Note that window.localStorage can be\n   * `null` in Android WebViews depending on how they are configured.\n   */\n  storage: AsyncStorage | undefined | null\n  /** The key to use when storing the cache */\n  key?: string\n  /** To avoid spamming,\n   * pass a time in ms to throttle saving the cache to disk */\n  throttleTime?: number\n  /**\n   * How to serialize the data to storage.\n   * @default `JSON.stringify`\n   */\n  serialize?: (client: PersistedClient) => string\n  /**\n   * How to deserialize the data from storage.\n   * @default `JSON.parse`\n   */\n  deserialize?: (cachedString: string) => PersistedClient\n\n  retry?: AsyncPersistRetryer\n}\n\nexport const createAsyncStoragePersister = ({\n  storage,\n  key = `REACT_QUERY_OFFLINE_CACHE`,\n  throttleTime = 1000,\n  serialize = JSON.stringify,\n  deserialize = JSON.parse,\n  retry,\n}: CreateAsyncStoragePersisterOptions): Persister => {\n  if (storage) {\n    const trySave = async (\n      persistedClient: PersistedClient,\n    ): Promise<Error | undefined> => {\n      try {\n        await storage.setItem(key, serialize(persistedClient))\n        return\n      } catch (error) {\n        return error as Error\n      }\n    }\n\n    return {\n      persistClient: asyncThrottle(\n        async (persistedClient) => {\n          let client: PersistedClient | undefined = persistedClient\n          let error = await trySave(client)\n          let errorCount = 0\n          while (error && client) {\n            errorCount++\n            client = await retry?.({\n              persistedClient: client,\n              error,\n              errorCount,\n            })\n\n            if (client) {\n              error = await trySave(client)\n            }\n          }\n        },\n        { interval: throttleTime },\n      ),\n      restoreClient: async () => {\n        const cacheString = await storage.getItem(key)\n\n        if (!cacheString) {\n          return\n        }\n\n        return deserialize(cacheString) as PersistedClient\n      },\n      removeClient: () => storage.removeItem(key),\n    }\n  }\n\n  return {\n    persistClient: noop,\n    restoreClient: () => Promise.resolve(undefined),\n    removeClient: noop,\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n"],"names":["noop","asyncThrottle","func","interval","onError","Error","timeout","running","lastTime","currentArgs","execFunc","async","args","error","Date","now","delayFunc","clearTimeout","setTimeout","tooSoon","storage","key","throttleTime","serialize","JSON","stringify","deserialize","parse","retry","trySave","setItem","persistedClient","persistClient","client","errorCount","restoreClient","cacheString","getItem","removeClient","removeItem","Promise","resolve","undefined"],"mappings":"kQAKA,MAAMA,EAAO,OAIN,SAASC,EACdC,GACAC,SAAEA,EAAW,IAAbC,QAAmBA,EAAUJ,GAA+B,IAE5D,GAAoB,mBAATE,EAAqB,MAAM,IAAIG,MAAM,6BAEhD,IAEIC,EAFAC,GAAU,EACVC,EAAW,EAEXC,EAA2B,KAE/B,MAAMC,EAAWC,UACf,GAAIF,EAAa,CACf,MAAMG,EAAOH,EACbA,EAAc,KACd,IACEF,GAAU,QACJL,KAAQU,GACd,MAAOC,GACPT,EAAQS,GACA,QACRL,EAAWM,KAAKC,MAChBR,GAAU,KAKVS,EAAYL,UAChBM,aAAaX,GACbA,EAAUY,YAAW,KACfX,EACFS,IAEAN,MAEDP,IAGL,MAAO,IAAIS,KACTH,EAAcG,EAEd,MAAMO,EAAUL,KAAKC,MAAQP,EAAWL,EACpCI,GAAWY,EACbH,IAEAN,KCoDN,SAASV,mCA9DkC,EACzCoB,UACAC,MAF0C,4BAG1CC,eAAe,IACfC,YAAYC,KAAKC,UACjBC,cAAcF,KAAKG,MACnBC,YAEA,GAAIR,EAAS,CACX,MAAMS,EAAUlB,UAGd,IAEE,kBADMS,EAAQU,QAAQT,EAAKE,EAAUQ,IAErC,MAAOlB,GACP,OAAOA,IAIX,MAAO,CACLmB,cAAe/B,GACbU,UACE,IAAIsB,EAAsCF,EACtClB,QAAcgB,EAAQI,GACtBC,EAAa,EACjB,KAAOrB,GAASoB,GACdC,IACAD,QAAS,MAAML,OAAN,EAAMA,EAAQ,CACrBG,gBAAiBE,EACjBpB,QACAqB,gBAGED,IACFpB,QAAcgB,EAAQI,MAI5B,CAAE9B,SAAUmB,IAEda,cAAexB,UACb,MAAMyB,QAAoBhB,EAAQiB,QAAQhB,GAE1C,GAAKe,EAIL,OAAOV,EAAYU,IAErBE,aAAc,IAAMlB,EAAQmB,WAAWlB,IAI3C,MAAO,CACLW,cAAehC,EACfmC,cAAe,IAAMK,QAAQC,aAAQC,GACrCJ,aAActC"}